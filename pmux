#!/bin/bash

# Start and manage a group of dtach sesssions
MYSELF="$0"

function doExit() {
	if [ ! $quiet ]; then
		echo "$1"

		if [ $2 -ne 0 ]; then
			read
		fi
	fi
	exit $2
}

function cmd() {
	local c
	local print=0
	local ssh_args=""

	if [ "$1" == "-p" ]; then
		print=1
		shift
	fi
	if [ "$1" == "-t" ]; then
		ssh_args="-t"
		shift
	fi

	if [[ "x" != "x${PMUX_HOST}" ]]; then
		c="ssh ${ssh_args} ${PMUX_HOST} "
	else
		c=""
	fi

	for arg in "$@"; do
		arg=`printf "%q" "${arg}"`

		if (( ssh > 0 )); then
			arg=`printf "%q" "${arg}"`
		fi

		c="${c}${arg} "
	done

	if (( print > 0 )); then
		echo $c
	else
		eval $c
	fi
}

function getSession() {
	local session=
	local count=0

	while IFS= read -r n; do
		f="${SESSION_DIR}/${n}"

		name=`echo "$n" | sed 's,[0-9]* ,,'`
		printf -v num "%02d" $count

		# Ensure that the session has the correct number in its name in case
		# any sessions have been closed.
		newpath="${SESSION_DIR}/$num $name"
		if [ "$f" != "${newpath}" ]; then
			cmd mv "$f" "${newpath}"
		fi

		if ((count == $1 )); then
			session="$newpath"
		fi
		count=$((count+1))
	done < <( (cmd ls -1 "${SESSION_DIR}") )

	echo ${session}
	return $count
}

# Start but don't attach to a session
# Usage: createSession <index>
function createSession() {
	printf -v num "%02d" $1

	path="${SESSION_DIR}/${num} -"
	(
		cd "$PMUX_PWD"
		export PMUX_PATH="${path}"
		cmd -t ${DTACH} -n "${PMUX_PATH}" ${DTACH_OPTS} $SHELL
	)
	echo "${path}"
}

# Wrapper for the kitty launch command for opening a tab, window, etc
function kittyLaunch() {
	local path="$1"
	shift
	local name=`basename "$path"`

	kitty @ launch $@ --tab-title "${name}"			\
		--copy-env									\
		--env PMUX_NAME="${PMUX_NAME}"				\
		--env PMUX_PWD="$PMUX_PWD"					\
		--env PMUX_PATH="${path}"					\
		--env PMUX_HOST="${PMUX_HOST}"				\
		--env PATH="${PATH}"						\
		${MYSELF} --attach-tab "${path}"
}

# Create a tab in kitty for each session in the directory, and let kitty manage
# the tabs. This script does not need to continue running since kitty will
# manage the tabs.
function openKittyTabs() {
	local count=0

	while IFS= read -r n; do
		f="${SESSION_DIR}/${n}"

		if (( count == 0 )); then
			OPTS="--type=overlay"
		else
			OPTS="--type=tab --location=last"
		fi

		if ((count != index)); then
			OPTS="${OPTS} --keep-focus"
		fi

		tabid=$(kittyLaunch "$f" ${OPTS})
		count=$((count+1))
	done < <( (cmd ls -1 "${SESSION_DIR}") )
}

function renameSession() {
	echo -en "Enter new name: "
	read
	num=`basename "$1" | sed 's,\([0-9]*\) .*,\1,'`
	newname="${SESSION_DIR}/${num} ${REPLY}"

	cmd test -f "${newname}"
	if [ $? -eq 0 ]; then
		echo "Names must be unique"
		read
	else
		cmd mv "$1" "${newname}"
	fi

	if [ $kittytabs ]; then
		name=`basename "${newname}"`
		kitty @ set-tab-title "${name}"

		export PMUX_PATH="${newname}"
	fi
}

homedir="${HOME}"
while [[ "$1" == "--"* ]]; do
	arg="$1"
	shift

	case "$arg" in
		--host)
			export PMUX_HOST="$1"

			homedir=`pwd`
			shift
			;;

		--kitty)
			if [ "x" != "x${SSH_TTY}" ]; then
				doExit "Unable to use kitty tabs with ssh" 1
			fi

			# Enable kitty tabs
			kittytabs=1
			;;

		--kitty-create-tab)
			kittycreatetab=1
			;;

		--kitty-rename-tab)
			kittyrenametab=1
			;;

		--attach-tab)
			export PMUX_PATH="$1"
			shift
			attachtab=1
			;;

		--attach)
			attachonly=1
			;;

		--quiet)
			quiet=1
			;;

		*)
			doExit "Unknown argument: $arg" 1
	esac
done

if [[ "x" == "x${PMUX_NAME}" ]]; then
	PMUX_NAME=$1
	shift
fi

if [[ "x" == "x${PMUX_NAME}" ]]; then
	doExit "Usage: $0 <name> [OPTIONS]" 1
fi
export PMUX_NAME

# Prefer dtach and fallback to abduco
DTACH=`cmd which dtach` 2>/dev/null
if [ $? -eq 0 ]; then
	export DTACH="${DTACH}"
	export DTACH_OPTS="-e ^a -z -r winch"
else
	DTACH=`cmd which abduco` 2>/dev/null
	if [ $? -eq 0 ]; then
		export DTACH="${DTACH} -e ^a"
		export DTACH_OPTS=""
	else
		doExit "Either abduco or dtach must be in the path to use pmux" 1
	fi
fi

if [ "x" == "x${PMUX_PWD}" ]; then
	export PMUX_PWD="${PWD}"
fi

# Set the directory so future commands can access it
export SESSION_DIR="${homedir}/.pmux/${PMUX_NAME}"
cmd mkdir -p "${SESSION_DIR}"

index=0
last=0
path=$(getSession $index)
count=$?

# If there are no sessions in the directory then create the default set by
# calling the script the caller provided.
#
# The caller should create any dtach sessions they wish in the session dir, but
# they must set the appropriate environment variables for those sessions
# including PMUX_PATH
if (( count == 0 )); then
	if [ $attachonly ]; then
		doExit "There are no existing sessions" 1
	else
		path=`createSession 0`
		index=0
		count=1
	fi
fi

if [ $kittytabs ]; then
	openKittyTabs
	doExit "" 0
elif [ $kittycreatetab ]; then
	# Just create a new tab
	printf -v num "%02d" $count
	path="${SESSION_DIR}/${num} -"

	# Start dtach for the new tab without attaching so the PWD will be set when
	# the tab does attach to it. This is a workaround for not being able to set
	# the dir when kitty starts the tab.
	(
		cd "$PMUX_PWD"
		export PMUX_PATH="${path}"
		cmd -t ${DTACH} -n "${PMUX_PATH}" ${DTACH_OPTS} $SHELL
	)

	tabid=$(kittyLaunch "${path}" --type=tab --location=last)
	doExit "" 0
elif [ $kittyrenametab ]; then
	# Rename the session runing in the kitty tab
	kittytabs=1

	if [ "x" == "x${PMUX_PATH}" ]; then
		doExit "PMUX_PATH must be set to use this" 1
	fi

	# TODO  The environment variable needs to be updated as well so that a 2nd
	#		rename works... There doesn't seem to be an obvious way to do this
	#		with kitty right now. The tab will get renamed but the session will
	#		not be.
	renameSession "${PMUX_PATH}"
	doExit "" $?
elif [ $attachtab ]; then
	cmd ${DTACH} -A "${PMUX_PATH}" ${DTACH_OPTS} ${SHELL}
	doExit "" $?
fi

while true; do
	if (( index >= count )); then
		path=`createSession ${index}`
		count=$((count+1))
	else
		path=$(getSession $index)
		count=$?
	fi

	# Attach to the session
	cmd -t ${DTACH} -A "${path}" ${DTACH_OPTS} ${SHELL}

	# We've now detached from the session, check to see if it has exited
	cmd test -S "${path}"
	if [ $? -ne 0 ]; then
		# A session has ended, don't try to read input.
		if (( count <= 1)); then
			# The session that ended was the last session
			doExit "Closing pmux session" 0
		fi

		if (( index > 0)); then
			index=$((index-1))
		else
			index=0
		fi
	else
		# The session has detached, but didn't exit. Prompt the user for an action.
		clear
		echo "pmux: Next|Prev|Alternate|Create|Detach"
		echo
		i=0

		while IFS= read -r n; do
			f="${SESSION_DIR}/${n}"

			if (( i == index )); then
				echo -en "*"
			else
				echo -en " "
			fi
			basename "$f"
			i=$((i+1))
		done < <( (cmd ls -1 "${SESSION_DIR}") )
		echo

		read -s -n1
		case "${REPLY}" in
			n)
				#next
				last=$index
				index=$((index+1))
				if (( index >= count )); then
					index=0
				fi
				;;
			p)
				# prev
				last=$index
				index=$((index-1))
				if (( index < 0 )); then
					index=$((count-1))
				fi
				;;
			c)
				# create
				last=$index
				index=$count
				;;

			0|1|2|3|4|5|6|7|8|9)
				if (( REPLY < count )); then
					last=$index
					index=${REPLY}
				fi
				;;

			# TODO shift+numbers

			d)
				# Detach
				doExit "" 0
				;;

			.)
				# rename
				renameSession "${path}"
				;;

			\?)
				(
					echo "n         next window"
					echo "p         prev window"
					echo "a         last active window"
					echo "c         create a new window"
					echo "d         detach"
					echo "0-9       jump to a specific window"
					echo
					echo "Sessions:"
					cmd ls -1 "${SESSION_DIR}"
				) | less
				;;

			"")
				;;

			a|*)
				# Last
				tmp=$last
				last=$index
				index=$tmp
				;;
		esac
	fi
done

